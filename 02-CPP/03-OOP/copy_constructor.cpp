#include <cassert>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <ostream>


/* 
    The rule of 3 in cpp
        - if a class has a destructor, a copy/move constructor 
          or an assignment(move) operator, it should have all three

    - The copy and move constructors define what happens when an object
      is initialized from another object of the same type.

    - The copy- and move-assignment operators define what happens when 
    we assign an object of a class type to another object of that same class type.


    - The destructor defines what happens when an object of the type ceases to exist.

    - If a class does not define all of the copy-control members,
     the compiler automatically defines the missing operations 
     which can lead to problems as the compiler defined versions might not behave as intended
    
 */

class String{
    private:
        char* str;
        uint64_t size;
    
    public:
        String()=default; // force a default constructor

        String(char* str) : str(str){
            size = strlen(str);
        }
        /* 
            Implicit copy constructor is generated by compiler 
            if no copy constructor exists, useful if all members
            are trivial data types else it may cause problems.
         */

        /*
            Explicit copy constructor
            - special constructor called for replicating an object.
            - copy constructor must pass its first argument as a reference to avoid infinite loop.

            The fact that the copy constructor is used to initialize nonreference parameters
            of class type explains why the copy constructor’s own parameter must be a reference.
            If that parameter were not a reference, then the call would never succeed—to call 
            the copy constructor, we’d need to use the copy constructor to copy the argument,
            but to copy the argument, we’d need to call the copy constructor, and so on indefinitely.

            T (const T& obj){}
            
        */
        String (const String &obj){
            size = obj.size + 1;
            str = new char[size]; // allocate in heap
            strcpy(str,obj.str);
        }

        void display()
        {
            std::cout << str << ' ' << size << std::endl;
        }

        void change_char(char ch, uint64_t idx){
            assert(idx < size);
            str[idx] = ch;
        }
};

String get_instance()
{
    static char arr[] = "New Temporary Instance!";
    String str {arr};
    return str;
}

int main(void)
{
    char arr[] = "Hello world";
    String s1(arr);
    String s2(s1); // this calls the compiler generated copy constructor

    s1.change_char('a', 0);

    // default copy constructor
    s1.display();
    s2.display(); // effects happen also on s2 (shallow copy)

    // Explicit copy constructor
    s1.display();
    s2.display(); // effects happen also on s2 (shallow copy)

    // get_instance() will return a temporary object
    // thus we must make the copy constructor const (RVALUE)
    String s3(get_instance());
    s3.display();

    return 0;
}
